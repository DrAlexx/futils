<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Futils: binary_tree::tree&lt; Key, T, B, Compare, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Futils
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">My collection of usefull utils</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classbinary__tree_1_1tree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbinary__tree_1_1tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">binary_tree::tree&lt; Key, T, B, Compare, Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__binary__tree.html">binary_tree</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a binary tree that can be cus.  
 <a href="classbinary__tree_1_1tree.html#details">More...</a></p>

<p><code>#include &lt;binary_tree.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a444e5ead4a7fdbde8512beaf5686dff3"><td class="memItemLeft" align="right" valign="top"><a id="a444e5ead4a7fdbde8512beaf5686dff3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a444e5ead4a7fdbde8512beaf5686dff3">key_type</a> = Node::key_type</td></tr>
<tr class="memdesc:a444e5ead4a7fdbde8512beaf5686dff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for Key. <br /></td></tr>
<tr class="separator:a444e5ead4a7fdbde8512beaf5686dff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af687ab5c8ae6bd82ffefb1a6927ef73a"><td class="memItemLeft" align="right" valign="top"><a id="af687ab5c8ae6bd82ffefb1a6927ef73a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#af687ab5c8ae6bd82ffefb1a6927ef73a">mapped_type</a> = Node::mapped_type</td></tr>
<tr class="memdesc:af687ab5c8ae6bd82ffefb1a6927ef73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for T. <br /></td></tr>
<tr class="separator:af687ab5c8ae6bd82ffefb1a6927ef73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591d19e03bf8259bad1d2e83170d2d1c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a591d19e03bf8259bad1d2e83170d2d1c">value_type</a> = Node::value_type</td></tr>
<tr class="separator:a591d19e03bf8259bad1d2e83170d2d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325cc0adc43aadacd4ce7cadfab60001"><td class="memItemLeft" align="right" valign="top"><a id="a325cc0adc43aadacd4ce7cadfab60001"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a325cc0adc43aadacd4ce7cadfab60001">key_compare</a> = Compare</td></tr>
<tr class="memdesc:a325cc0adc43aadacd4ce7cadfab60001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for Compare. <br /></td></tr>
<tr class="separator:a325cc0adc43aadacd4ce7cadfab60001"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea935e6d7c808c009cdc02bb7da495d2"><td class="memItemLeft" align="right" valign="top"><a id="aea935e6d7c808c009cdc02bb7da495d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#aea935e6d7c808c009cdc02bb7da495d2">tree</a> () noexcept</td></tr>
<tr class="memdesc:aea935e6d7c808c009cdc02bb7da495d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">tree creates empty tree <br /></td></tr>
<tr class="separator:aea935e6d7c808c009cdc02bb7da495d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae50a8ca9653cc614655733fdcba232"><td class="memItemLeft" align="right" valign="top"><a id="aaae50a8ca9653cc614655733fdcba232"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#aaae50a8ca9653cc614655733fdcba232">tree</a> (<a class="el" href="classbinary__tree_1_1tree.html">tree</a> &amp;)=delete</td></tr>
<tr class="memdesc:aaae50a8ca9653cc614655733fdcba232"><td class="mdescLeft">&#160;</td><td class="mdescRight">tree not impl yet <br /></td></tr>
<tr class="separator:aaae50a8ca9653cc614655733fdcba232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba715932e7acdd81ba341c262ccc666"><td class="memItemLeft" align="right" valign="top"><a id="a9ba715932e7acdd81ba341c262ccc666"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a9ba715932e7acdd81ba341c262ccc666">tree</a> (<a class="el" href="classbinary__tree_1_1tree.html">tree</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a9ba715932e7acdd81ba341c262ccc666"><td class="mdescLeft">&#160;</td><td class="mdescRight">tree not impl yet <br /></td></tr>
<tr class="separator:a9ba715932e7acdd81ba341c262ccc666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336f15e1cc530127bf821b10e98efa1f"><td class="memItemLeft" align="right" valign="top"><a id="a336f15e1cc530127bf821b10e98efa1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a336f15e1cc530127bf821b10e98efa1f">~tree</a> ()</td></tr>
<tr class="memdesc:a336f15e1cc530127bf821b10e98efa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">~tree destructor <br /></td></tr>
<tr class="separator:a336f15e1cc530127bf821b10e98efa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1258e06c2179be089c4d7724f17bbb54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a1258e06c2179be089c4d7724f17bbb54">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a1258e06c2179be089c4d7724f17bbb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty  <a href="classbinary__tree_1_1tree.html#a1258e06c2179be089c4d7724f17bbb54">More...</a><br /></td></tr>
<tr class="separator:a1258e06c2179be089c4d7724f17bbb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ebf9f380409c46aa6725abb7740c25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a23ebf9f380409c46aa6725abb7740c25">size</a> () const noexcept</td></tr>
<tr class="memdesc:a23ebf9f380409c46aa6725abb7740c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">size  <a href="classbinary__tree_1_1tree.html#a23ebf9f380409c46aa6725abb7740c25">More...</a><br /></td></tr>
<tr class="separator:a23ebf9f380409c46aa6725abb7740c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714e7d54455c1e3df6776c09b4fce1a9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a714e7d54455c1e3df6776c09b4fce1a9">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a714e7d54455c1e3df6776c09b4fce1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">max_size  <a href="classbinary__tree_1_1tree.html#a714e7d54455c1e3df6776c09b4fce1a9">More...</a><br /></td></tr>
<tr class="separator:a714e7d54455c1e3df6776c09b4fce1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cf97d095fc3ec11246df99c2e2767c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a16cf97d095fc3ec11246df99c2e2767c">insert</a> (const <a class="el" href="classbinary__tree_1_1tree.html#a591d19e03bf8259bad1d2e83170d2d1c">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a16cf97d095fc3ec11246df99c2e2767c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element into the container, if the container doesn't already contain an element with an equivalent key.  <a href="classbinary__tree_1_1tree.html#a16cf97d095fc3ec11246df99c2e2767c">More...</a><br /></td></tr>
<tr class="separator:a16cf97d095fc3ec11246df99c2e2767c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bf57f23d779334790b8d20c10f38a9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a16bf57f23d779334790b8d20c10f38a9">erase</a> (const <a class="el" href="classbinary__tree_1_1tree.html#a444e5ead4a7fdbde8512beaf5686dff3">key_type</a> &amp;key) noexcept</td></tr>
<tr class="memdesc:a16bf57f23d779334790b8d20c10f38a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase Removes specified elements from the container.  <a href="classbinary__tree_1_1tree.html#a16bf57f23d779334790b8d20c10f38a9">More...</a><br /></td></tr>
<tr class="separator:a16bf57f23d779334790b8d20c10f38a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7a1e02dcde0bf29c6c2743c8a80c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a3e7a1e02dcde0bf29c6c2743c8a80c47">swap</a> (<a class="el" href="classbinary__tree_1_1tree.html">tree</a>&lt; Key, T, B, Compare, Alloc &gt; &amp;other)</td></tr>
<tr class="memdesc:a3e7a1e02dcde0bf29c6c2743c8a80c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap Exchanges the contents of the container with those of other.  <a href="classbinary__tree_1_1tree.html#a3e7a1e02dcde0bf29c6c2743c8a80c47">More...</a><br /></td></tr>
<tr class="separator:a3e7a1e02dcde0bf29c6c2743c8a80c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542aa49593ee084e4c2cca81a5052612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a542aa49593ee084e4c2cca81a5052612">clear</a> ()</td></tr>
<tr class="memdesc:a542aa49593ee084e4c2cca81a5052612"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear Erases all elements from the container.  <a href="classbinary__tree_1_1tree.html#a542aa49593ee084e4c2cca81a5052612">More...</a><br /></td></tr>
<tr class="separator:a542aa49593ee084e4c2cca81a5052612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c337d8e72eff4e6fee9fc77bbe89fd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a70c337d8e72eff4e6fee9fc77bbe89fd">count</a> (const <a class="el" href="classbinary__tree_1_1tree.html#a444e5ead4a7fdbde8512beaf5686dff3">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a70c337d8e72eff4e6fee9fc77bbe89fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">count Returns the number of elements with key that compares equivalent to the specified argument.  <a href="classbinary__tree_1_1tree.html#a70c337d8e72eff4e6fee9fc77bbe89fd">More...</a><br /></td></tr>
<tr class="separator:a70c337d8e72eff4e6fee9fc77bbe89fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c86d6c1d128ba15af6bd2c355d5ebde"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a2c86d6c1d128ba15af6bd2c355d5ebde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a2c86d6c1d128ba15af6bd2c355d5ebde">enumerate</a> (F f)</td></tr>
<tr class="memdesc:a2c86d6c1d128ba15af6bd2c355d5ebde"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls functor f for every element in the tree  <a href="classbinary__tree_1_1tree.html#a2c86d6c1d128ba15af6bd2c355d5ebde">More...</a><br /></td></tr>
<tr class="separator:a2c86d6c1d128ba15af6bd2c355d5ebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895e3f5162f5c9ad0defcb70b2fb0301"><td class="memTemplParams" colspan="2"><a id="a895e3f5162f5c9ad0defcb70b2fb0301"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a895e3f5162f5c9ad0defcb70b2fb0301"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a895e3f5162f5c9ad0defcb70b2fb0301">check_height_test</a> (F check_height) const</td></tr>
<tr class="memdesc:a895e3f5162f5c9ad0defcb70b2fb0301"><td class="mdescLeft">&#160;</td><td class="mdescRight">check_height_test for testing purposes only! <br /></td></tr>
<tr class="separator:a895e3f5162f5c9ad0defcb70b2fb0301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d67b94b4946f1ef736b655adc335441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__tree_1_1tree.html#a4d67b94b4946f1ef736b655adc335441">dump_tree</a> (std::ostringstream &amp;ss) const</td></tr>
<tr class="memdesc:a4d67b94b4946f1ef736b655adc335441"><td class="mdescLeft">&#160;</td><td class="mdescRight">dump_tree dumps tree content into graphviz BST format  <a href="classbinary__tree_1_1tree.html#a4d67b94b4946f1ef736b655adc335441">More...</a><br /></td></tr>
<tr class="separator:a4d67b94b4946f1ef736b655adc335441"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename T = void, typename B = binary_tree::avl_balancer, typename Compare = std::less&lt;Key&gt;, template&lt; typename X &gt; typename Alloc = std::allocator&gt;<br />
class binary_tree::tree&lt; Key, T, B, Compare, Alloc &gt;</h3>

<p>Keys are sorted by using the comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Type of the keys. Each element in a tree is uniquely identified by its key value. Aliased as member type <a class="el" href="classbinary__tree_1_1tree.html#a444e5ead4a7fdbde8512beaf5686dff3" title="Alias for Key.">tree::key_type</a>. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the mapped value. Each element in a tree stores some data as its mapped value. Aliased as member type <a class="el" href="classbinary__tree_1_1tree.html#af687ab5c8ae6bd82ffefb1a6927ef73a" title="Alias for T.">tree::mapped_type</a>. By the default this type is void. </td></tr>
    <tr><td class="paramname">B</td><td>balancer type. Now ypu can use only binary_tree::avl_balancer here! </td></tr>
    <tr><td class="paramname">Compare</td><td>A binary predicate that takes two element keys as arguments and returns a bool. The expression comp(a,b), where comp is an object of this type and a and b are key values, shall return true if a is considered to go before b in the strict weak ordering the function defines. The map object uses this expression to determine both the order the elements follow in the container and whether two element keys are equivalent (by comparing them reflexively: they are equivalent if !comp(a,b) &amp;&amp; !comp(b,a)). No two elements in a map container can have equivalent keys. This can be a function pointer or a function object (see constructor for an example). This defaults to less&lt;T&gt;, which returns the same as applying the less-than operator (a&lt;b). Aliased as member type <a class="el" href="classbinary__tree_1_1tree.html#a325cc0adc43aadacd4ce7cadfab60001" title="Alias for Compare.">tree::key_compare</a>. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a591d19e03bf8259bad1d2e83170d2d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591d19e03bf8259bad1d2e83170d2d1c">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T  = void, typename B  = binary_tree::avl_balancer, typename Compare  = std::less&lt;Key&gt;, template&lt; typename X &gt; typename Alloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::<a class="el" href="classbinary__tree_1_1tree.html#a591d19e03bf8259bad1d2e83170d2d1c">value_type</a> =  Node::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When T isn't void value_type is std::pair&lt;Key,T&gt;. In the other case it is alias for Key </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a542aa49593ee084e4c2cca81a5052612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542aa49593ee084e4c2cca81a5052612">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename B , typename Compare , template&lt; typename X &gt; typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After this call, <a class="el" href="classbinary__tree_1_1tree.html#a23ebf9f380409c46aa6725abb7740c25" title="size">size()</a> returns zero. </p>

</div>
</div>
<a id="a70c337d8e72eff4e6fee9fc77bbe89fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c337d8e72eff4e6fee9fc77bbe89fd">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T  = void, typename B  = binary_tree::avl_balancer, typename Compare  = std::less&lt;Key&gt;, template&lt; typename X &gt; typename Alloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbinary__tree_1_1tree.html#a444e5ead4a7fdbde8512beaf5686dff3">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>value of the elements to count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with key that compares equivalent to key or x, which is either 1 or 0 for (1). </dd></dl>

</div>
</div>
<a id="a4d67b94b4946f1ef736b655adc335441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d67b94b4946f1ef736b655adc335441">&#9670;&nbsp;</a></span>dump_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T  = void, typename B  = binary_tree::avl_balancer, typename Compare  = std::less&lt;Key&gt;, template&lt; typename X &gt; typename Alloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::dump_tree </td>
          <td>(</td>
          <td class="paramtype">std::ostringstream &amp;&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1258e06c2179be089c4d7724f17bbb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1258e06c2179be089c4d7724f17bbb54">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename B , typename Compare , template&lt; typename X &gt; typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if tree is empty otherwise false </dd></dl>

</div>
</div>
<a id="a2c86d6c1d128ba15af6bd2c355d5ebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c86d6c1d128ba15af6bd2c355d5ebde">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename B , typename Compare , template&lt; typename X &gt; typename Alloc&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::enumerate </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>functional object type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16bf57f23d779334790b8d20c10f38a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bf57f23d779334790b8d20c10f38a9">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T  = void, typename B  = binary_tree::avl_balancer, typename Compare  = std::less&lt;Key&gt;, template&lt; typename X &gt; typename Alloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbinary__tree_1_1tree.html#a444e5ead4a7fdbde8512beaf5686dff3">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed. </dd></dl>

</div>
</div>
<a id="a16cf97d095fc3ec11246df99c2e2767c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cf97d095fc3ec11246df99c2e2767c">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T  = void, typename B  = binary_tree::avl_balancer, typename Compare  = std::less&lt;Key&gt;, template&lt; typename X &gt; typename Alloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbinary__tree_1_1tree.html#a591d19e03bf8259bad1d2e83170d2d1c">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>element value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when an element was inserted otherwise false </dd></dl>

</div>
</div>
<a id="a714e7d54455c1e3df6776c09b4fce1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714e7d54455c1e3df6776c09b4fce1a9">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename B , typename Compare , template&lt; typename X &gt; typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::max_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum possible number of elements </dd></dl>

</div>
</div>
<a id="a23ebf9f380409c46aa6725abb7740c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ebf9f380409c46aa6725abb7740c25">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename B , typename Compare , template&lt; typename X &gt; typename Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of elements in the container </dd></dl>

</div>
</div>
<a id="a3e7a1e02dcde0bf29c6c2743c8a80c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7a1e02dcde0bf29c6c2743c8a80c47">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename B , typename Compare , template&lt; typename X &gt; typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbinary__tree_1_1tree.html">binary_tree::tree</a>&lt; Key, T, B, Compare, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbinary__tree_1_1tree.html">tree</a>&lt; Key, T, B, Compare, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does not invoke any move, copy, or swap operations on individual elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>binary_tree</b></li><li class="navelem"><a class="el" href="classbinary__tree_1_1tree.html">tree</a></li>
    <li class="footer">Generated on Wed May 12 2021 17:04:32 for Futils by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
